// Fichier concat√©n√© de tous les fichiers TypeScript valides du projet
// Fichier: src/app/core/models/user.model.ts
export interface User {
  uid: string;
  email: string;
  displayName?: string;
  roles: ('admin' | 'user')[];
  createdAt: Date | any;
}


// Fichier: src/app/core/models/place.model.ts
export interface Place {
  id?: string;
  name: string;
  description: string;
  latitude: number;
  longitude: number;
  categories: string[];
  images: string[];      // URLs des images
  videos?: string[];     // URLs des vid√©os (optionnel)
  status: 'pending' | 'approved' | 'rejected';
  createdBy: string;     // UID ou ID de l'utilisateur ayant cr√©√© le lieu
  createdAt: Date | any; // compatibilit√© Timestamp Firestore
  updatedAt?: Date | any;
  validatedBy?: string;  // UID ou ID de l'admin qui a valid√©
  validatedAt?: Date | any;
}


// Fichier: src/app/core/components/footer/footer.component.ts
import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-footer',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './footer.component.html',
  styleUrls: ['./footer.component.css']
})
export class FooterComponent {}


// Fichier: src/app/core/components/header/header.component.ts
import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule, Router } from '@angular/router';
import { Observable } from 'rxjs';

import { AuthService } from '../../services/auth.service';
import { User } from '../../models/user.model';

@Component({
  selector: 'app-header',
  standalone: true,
  imports: [CommonModule, RouterModule],
  templateUrl: './header.component.html',
  styleUrls: ['./header.component.css']
})
export class HeaderComponent {
  user$: Observable<User | null | undefined>;
  isMobileMenuOpen = false;

  constructor(private auth: AuthService, private router: Router) {
    this.user$ = this.auth.user$;
  }

  toggleMobileMenu() {
    this.isMobileMenuOpen = !this.isMobileMenuOpen;
  }

  async logout() {
    await this.auth.signOut();
    this.router.navigate(['/login']);
    this.isMobileMenuOpen = false;
  }
}


// Fichier: src/app/core/services/auth.service.ts
import { Injectable, inject } from '@angular/core';
import { Auth, authState, GoogleAuthProvider, signInWithPopup, signOut, User as FirebaseUser } from '@angular/fire/auth';
import { Firestore, doc, setDoc, docData } from '@angular/fire/firestore';
import { Observable, of, from } from 'rxjs';
import { switchMap } from 'rxjs/operators';
import { User } from '../models/user.model';

@Injectable({
  providedIn: 'root'
})
export class AuthService {
  // Injection directe des services modulaires
  private auth: Auth = inject(Auth);
  private firestore: Firestore = inject(Firestore);

  user$: Observable<User | null | undefined>;

  constructor() {
    // authState() est la version modulaire de afAuth.authState
    this.user$ = authState(this.auth).pipe(
      switchMap((user: FirebaseUser | null) => {
        if (user) {
          // docData() remplace valueChanges()
          const userDocRef = doc(this.firestore, `users/${user.uid}`);
          return docData(userDocRef) as Observable<User>;
        } else {
          return of(null);
        }
      })
    );
  }

  // Connexion Google (Promise)
  async googleSignin(): Promise<void> {
    const provider = new GoogleAuthProvider();
    try {
      const credential = await signInWithPopup(this.auth, provider);
      await this.updateUserData(credential.user);
    } catch (error) {
      console.error("Erreur AuthService (Modulaire):", error);
      throw error;
    }
  }

  // D√©connexion
  async signOut(): Promise<void> {
    await signOut(this.auth);
  }

  // Mise √† jour des donn√©es utilisateur
  private async updateUserData(user: FirebaseUser): Promise<void> {
    const userDocRef = doc(this.firestore, `users/${user.uid}`);
    
    const data: User = {
      uid: user.uid,
      email: user.email || '',
      displayName: user.displayName || '',
      roles: ['admin'], // Attention : merge: true prot√®ge les donn√©es existantes
      createdAt: new Date()
    };

    // setDoc avec { merge: true } remplace userRef.set(..., { merge: true })
    await setDoc(userDocRef, data, { merge: true });
  }
}


// Fichier: src/app/core/services/supabase-image.ts
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root',
})
export class SupabaseImage {
  
}


// Fichier: src/app/core/services/supabase-image.service.ts
import { Injectable } from '@angular/core';
import { createClient, SupabaseClient } from '@supabase/supabase-js';
import { environment } from '../../../environments/environment';

@Injectable({
  providedIn: 'root'
})
export class SupabaseImageService {
  private supabase: SupabaseClient | null = null;
  private bucketName = 'places-images';

  constructor() {
    const sbUrl = (environment as any).supabaseUrl;
    const sbKey = (environment as any).supabaseKey;

    if (sbUrl && sbKey && !sbUrl.includes('votre-projet')) {
      this.supabase = createClient(sbUrl, sbKey);
      console.log('‚úÖ Supabase initialis√© avec succ√®s.');
    } else {
      console.warn('‚ö†Ô∏è Supabase non configur√© ou cl√©s par d√©faut d√©tect√©es.');
    }
  }

  async uploadImage(file: File, path: string): Promise<string | null> {
    if (!this.supabase) {
      throw new Error('Supabase client non initialis√©. V√©rifiez environment.ts');
    }

    // 1. Upload
    console.log(`üì§ Upload vers ${this.bucketName}/${path}...`);
    const { data, error } = await this.supabase.storage
      .from(this.bucketName)
      .upload(path, file, { upsert: true });

    if (error) {
      console.error('‚ùå Erreur Upload Supabase:', error);
      throw error;
    }

    // 2. Get Public URL
    const { data: publicUrlData } = this.supabase.storage
      .from(this.bucketName)
      .getPublicUrl(path);
    
    const finalUrl = publicUrlData.publicUrl;
    console.log('‚úÖ Image upload√©e:', finalUrl);
    
    return finalUrl;
  }
}


// Fichier: src/app/core/services/places.ts
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root',
})
export class Places {
  
}


// Fichier: src/app/core/services/places.service.ts
import { Injectable, inject } from '@angular/core';
import {
  Firestore,
  collection,
  collectionData,
  doc,
  docData,
  addDoc,
  query,
  where,
  updateDoc,
  deleteDoc
} from '@angular/fire/firestore';
import { Observable } from 'rxjs';
import { Place } from '../models/place.model';

@Injectable({
  providedIn: 'root'
})
export class PlacesService {
  private firestore: Firestore = inject(Firestore);

  constructor() {}

  // Lieux approuv√©s (affich√©s sur la carte)
  getApprovedPlaces(): Observable<Place[]> {
    const placesRef = collection(this.firestore, 'places');
    const q = query(placesRef, where('status', '==', 'approved'));
    return collectionData(q, { idField: 'id' }) as Observable<Place[]>;
  }

  // Lieu par ID
  getPlaceById(id: string): Observable<Place | undefined> {
    const placeDocRef = doc(this.firestore, `places/${id}`);
    return docData(placeDocRef, { idField: 'id' }) as Observable<Place>;
  }

  // ‚ûï Ajouter un lieu
  addPlace(place: Place): Promise<any> {
    const placesRef = collection(this.firestore, 'places');
    return addDoc(placesRef, place);
  }

  // ‚úèÔ∏è Mise √† jour g√©n√©rique
  updatePlace(id: string, data: Partial<Place>): Promise<void> {
    const placeDocRef = doc(this.firestore, `places/${id}`);
    return updateDoc(placeDocRef, data as any);
  }

  // üóë Supprimer un lieu
  deletePlace(id: string): Promise<void> {
    const placeDocRef = doc(this.firestore, `places/${id}`);
    return deleteDoc(placeDocRef);
  }

  // üïí Lieux en attente (pour admin)
  getPendingPlaces(): Observable<Place[]> {
    const placesRef = collection(this.firestore, 'places');
    const q = query(placesRef, where('status', '==', 'pending'));
    return collectionData(q, { idField: 'id' }) as Observable<Place[]>;
  }

  // üë§ Lieux cr√©√©s par un utilisateur donn√© (pour non-admin)
  getPlacesByUser(userId: string): Observable<Place[]> {
    const placesRef = collection(this.firestore, 'places');
    const q = query(placesRef, where('createdBy', '==', userId));
    return collectionData(q, { idField: 'id' }) as Observable<Place[]>;
  }

  // ‚úÖ Approuver un lieu (admin)
  approvePlace(id: string, adminId: string): Promise<void> {
    return this.updatePlace(id, {
      status: 'approved',
      validatedBy: adminId,
      validatedAt: new Date(),
      updatedAt: new Date()
    });
  }

  // ‚ùå Rejeter un lieu (admin)
  rejectPlace(id: string): Promise<void> {
    return this.updatePlace(id, {
      status: 'rejected',
      updatedAt: new Date()
    });
  }
}


// Fichier: src/app/core/services/supabase.service.ts
import { Injectable } from '@angular/core';
import { createClient, SupabaseClient } from '@supabase/supabase-js';

@Injectable({
  providedIn: 'root'
})
export class SupabaseService {
  private supabase: SupabaseClient;

  constructor() {
    this.supabase = createClient(
      'https://bcuxfuqgwoqyammgmpjw.supabase.co', 
      'sb_secret_GnRXdBMwhJqpO4LZGKfwKg_HbVpIYjh'
    );
  }

  async uploadImage(file: File): Promise<string> {
    const timestamp = Date.now();
    const cleanName = file.name.replace(/[^a-z0-9]/gi, '_');
    const fileName = `place_${timestamp}_${cleanName}`;
    
    const { data, error } = await this.supabase.storage
      .from('places')
      .upload(fileName, file, { 
        cacheControl: '3600',
        upsert: false 
      });
    
    if (error) {
      throw new Error(`Upload failed: ${error.message}`);
    }
    
    const { data: urlData } = this.supabase.storage
      .from('places')
      .getPublicUrl(fileName);
    
    return urlData.publicUrl;
  }
}


// Fichier: src/app/core/services/auth.ts
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root',
})
export class Auth {
  
}


// Fichier: src/app/core/guards/auth-guard.ts
import { CanActivateFn } from '@angular/router';

export const authGuard: CanActivateFn = (route, state) => {
  return true;
};


// Fichier: src/app/core/guards/auth.guard.ts
import { Injectable } from '@angular/core';
import { CanActivate, Router } from '@angular/router';
import { Observable } from 'rxjs';
import { map, take, tap } from 'rxjs/operators';
import { AuthService } from '../services/auth.service';

@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanActivate {
  constructor(private auth: AuthService, private router: Router) {}

  canActivate(): Observable<boolean> {
    return this.auth.user$.pipe(
      take(1),
      map(user => !!user), // Transforme l'objet user en bool√©en
      tap(loggedIn => {
        if (!loggedIn) {
          console.log('Acc√®s refus√© : connexion requise');
          this.router.navigate(['/login']);
        }
      })
    );
  }
}


// Fichier: src/app/core/guards/admin-guard.ts
import { CanActivateFn } from '@angular/router';

export const adminGuard: CanActivateFn = (route, state) => {
  return true;
};


// Fichier: src/app/core/guards/admin.guard.ts
import { Injectable, inject } from '@angular/core';
import { CanActivate, Router, UrlTree } from '@angular/router';
import { Auth, authState, getIdTokenResult } from '@angular/fire/auth';
import { Observable } from 'rxjs';
import { map, take, switchMap } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class AdminGuard implements CanActivate {
  private auth = inject(Auth);
  private router = inject(Router);

  canActivate(): Observable<boolean | UrlTree> {
    // On √©coute l'√©tat d'authentification
    return authState(this.auth).pipe(
      take(1), // On prend juste la valeur actuelle
      switchMap(async (user) => {
        if (!user) {
          console.warn('AdminGuard: Pas d\'utilisateur connect√©.');
          return false;
        }

        // On force le rafra√Æchissement du token pour avoir les derniers claims
        // (Important si on vient de lancer le script setAdmin.js)
        const tokenResult = await getIdTokenResult(user, true);
        
        // On v√©rifie si le claim 'admin' est pr√©sent et vrai
        const isAdmin = !!tokenResult.claims['admin'];

        if (isAdmin) {
          console.log('‚úÖ AdminGuard: Acc√®s autoris√©.');
          return true;
        } else {
          console.error('‚õî AdminGuard: Acc√®s refus√©. Claims:', tokenResult.claims);
          return false;
        }
      }),
      map(isAuthorized => {
        if (isAuthorized) return true;
        
        // Si refus√©, redirection vers l'accueil avec un param√®tre d'erreur
        // return this.router.createUrlTree(['/'], { queryParams: { error: 'admin_required' } });
        
        // Ou simplement false (la page ne chargera pas)
        alert('Acc√®s refus√© : droits administrateur requis');
        return this.router.createUrlTree(['/']); 
      })
    );
  }
}


// Fichier: src/app/app.routes.ts
import { Routes } from '@angular/router';
import { MapPageComponent } from './features/map/pages/map-page/map-page.component';
import { PlaceDetailComponent } from './features/map/pages/place-detail/place-detail.component';
import { AddPlaceComponent } from './features/admin/pages/add-place/add-place.component';
import { LoginComponent } from './features/auth/pages/login/login.component';
import { AdminListComponent } from './features/admin/pages/admin-list/admin-list.component';
import { AuthGuard } from './core/guards/auth.guard';
import { AdminGuard } from './core/guards/admin.guard';

export const routes: Routes = [
  { path: '', component: MapPageComponent },
  { path: 'place/:id', component: PlaceDetailComponent },
  { path: 'add-place', component: AddPlaceComponent, canActivate: [AuthGuard] },
  { path: 'login', component: LoginComponent },
  { 
    path: 'admin',
    canActivate: [AdminGuard],
    children: [
        { path: 'places', component: AdminListComponent },
        { path: '', redirectTo: 'places', pathMatch: 'full' }
    ]
  },
  { path: '**', redirectTo: '' }
];


// Fichier: src/app/features/auth/pages/login/login.component.ts
import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Router } from '@angular/router';
import { AuthService } from '../../../../core/services/auth.service';

@Component({
  selector: 'app-login',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './login.component.html',
  styleUrls: ['./login.component.css']
})
export class LoginComponent {
  isLoading = false;
  errorMessage = '';
  debugInfo = ''; // Ajout pour voir l'erreur brute

  constructor(private auth: AuthService, private router: Router) {}

  async loginWithGoogle() {
    this.isLoading = true;
    this.errorMessage = '';
    this.debugInfo = '';
    
    try {
      console.log('Tentative de connexion Google...');
      await this.auth.googleSignin();
      console.log('Connexion r√©ussie !');
      this.router.navigate(['/']);
    } catch (err: any) {
      console.error('Erreur login d√©taill√©e:', err);
      
      // Affichage de l'erreur brute pour le d√©veloppeur
      this.debugInfo = JSON.stringify(err, null, 2);
      
      if (err.code === 'auth/popup-closed-by-user') {
        this.errorMessage = "Connexion annul√©e par l'utilisateur.";
      } else if (err.code === 'auth/configuration-not-found') {
        this.errorMessage = "Google Auth n'est pas activ√© dans la console Firebase.";
      } else if (err.code === 'auth/unauthorized-domain') {
        this.errorMessage = "Le domaine localhost n'est pas autoris√© dans Firebase Auth.";
      } else {
        this.errorMessage = "Erreur : " + (err.message || "Inconnue");
      }
    } finally {
      this.isLoading = false;
    }
  }
}


// Fichier: src/app/features/admin/pages/add-place/add-place.component.ts
import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule, NgForm } from '@angular/forms';
import { LeafletModule } from '@bluehalo/ngx-leaflet';
import * as L from 'leaflet';
import { Router } from '@angular/router';
import { PlacesService } from '../../../../core/services/places.service';
import { SupabaseImageService } from '../../../../core/services/supabase-image.service';
import { AuthService } from '../../../../core/services/auth.service';
import { Place } from '../../../../core/models/place.model';
import { firstValueFrom } from 'rxjs';

@Component({
  selector: 'app-add-place',
  standalone: true,
  imports: [CommonModule, FormsModule, LeafletModule],
  templateUrl: './add-place.component.html',
  styleUrls: ['./add-place.component.css']
})
export class AddPlaceComponent implements OnInit {
  // Mod√®le de base du formulaire
  model: Partial<Place> = {
    name: '',
    description: '',
    latitude: 34.71,
    longitude: 11.15,
    categories: [],
    images: [],
    videos: [],
    status: 'pending'
  };

  categoriesList: string[] = [
    'Restaurant',
    'Fruits de mer',
    'Caf√©',
    'Fast-food',
    'Pizzeria',
    'Boulangerie',
    'Glacier',
    'Bar',
    'H√¥tel',
    'Maison d‚Äôh√¥tes',
    'Camping',
    'Plage',
    'Parc',
    'Jardin',
    'Randonn√©e',
    'Mus√©e',
    'Monument',
    'Site historique',
    'Site arch√©ologique',
    'Centre commercial',
    'March√©',
    'Souk',
    'Commerce',
    'Spa',
    'Bien-√™tre',
    'Activit√©s nautiques',
    'P√™che',
    'Famille',
    'Romantique',
    'Vue panoramique'
  ];

  isSubmitting = false;
  uploadingImages = false;
  uploadingVideos = false;
  errorMessage = '';
  successMessage = '';

  mapOptions: L.MapOptions = {
    layers: [
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18
      })
    ],
    zoom: 10,
    center: L.latLng(34.71, 11.15)
  };

  marker: L.Marker | null = null;

  constructor(
    private placesService: PlacesService,
    private imageService: SupabaseImageService,
    private auth: AuthService,
    private router: Router
  ) {
    const iconRetinaUrl =
      'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-2x.png';
    const iconUrl =
      'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png';
    const shadowUrl =
      'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png';

    (L.Marker.prototype as any).options.icon = L.icon({
      iconRetinaUrl,
      iconUrl,
      shadowUrl,
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      tooltipAnchor: [16, -28],
      shadowSize: [41, 41]
    });
  }

  ngOnInit(): void {
    this.updateMarker(this.model.latitude!, this.model.longitude!);
  }

  onMapReady(map: L.Map) {
    map.on('click', (e: L.LeafletMouseEvent) => {
      this.model.latitude = e.latlng.lat;
      this.model.longitude = e.latlng.lng;
      this.updateMarker(e.latlng.lat, e.latlng.lng);
    });
  }

  updateMarker(lat: number, lng: number) {
    if (this.marker) {
      this.marker.setLatLng([lat, lng]);
    } else {
      this.marker = L.marker([lat, lng]);
    }
  }

  get mapLayers(): L.Layer[] {
    return this.marker ? [this.marker] : [];
  }

  // Cat√©gories (checkbox)
  toggleCategory(cat: string, event: Event) {
    const input = event.target as HTMLInputElement;
    const checked = input.checked;

    if (!this.model.categories) {
      this.model.categories = [];
    }

    if (checked) {
      if (!this.model.categories.includes(cat)) {
        this.model.categories.push(cat);
      }
    } else {
      this.model.categories = this.model.categories.filter(c => c !== cat);
    }
  }

  // Upload d'IMAGES
  async onImagesSelected(event: Event) {
    const input = event.target as HTMLInputElement;
    if (!input.files || input.files.length === 0) return;

    const files = Array.from(input.files);
    this.uploadingImages = true;
    this.errorMessage = '';

    try {
      if (!this.model.images) this.model.images = [];

      for (const file of files) {
        const safeName = file.name.replace(/[^a-zA-Z0-9.]/g, '_');
        const fileName = `${Date.now()}_${safeName}`;
        const path = `images/${fileName}`;
        const url = await this.imageService.uploadImage(file, path);
        if (url) this.model.images.push(url);
      }

      input.value = '';
    } catch (err: any) {
      console.error('Upload images failed', err);
      this.errorMessage =
        "Erreur lors de l'upload des images : " +
        (err?.message || 'V√©rifiez votre configuration Supabase');
    } finally {
      this.uploadingImages = false;
    }
  }

  // Upload de VIDEOS
  async onVideosSelected(event: Event) {
    const input = event.target as HTMLInputElement;
    if (!input.files || input.files.length === 0) return;

    const files = Array.from(input.files);
    this.uploadingVideos = true;
    this.errorMessage = '';

    try {
      if (!this.model.videos) this.model.videos = [];

      for (const file of files) {
        const safeName = file.name.replace(/[^a-zA-Z0-9.]/g, '_');
        const fileName = `${Date.now()}_${safeName}`;
        const path = `videos/${fileName}`;
        const url = await this.imageService.uploadImage(file, path);
        if (url) this.model.videos.push(url);
      }

      input.value = '';
    } catch (err: any) {
      console.error('Upload videos failed', err);
      this.errorMessage =
        "Erreur lors de l'upload des vid√©os : " +
        (err?.message || 'V√©rifiez votre configuration Supabase');
    } finally {
      this.uploadingVideos = false;
    }
  }

  removeImage(url: string) {
    if (!this.model.images) return;
    this.model.images = this.model.images.filter(i => i !== url);
  }

  removeVideo(url: string) {
    if (!this.model.videos) return;
    this.model.videos = this.model.videos.filter(v => v !== url);
  }

  // Soumission du formulaire
  async onSubmit(form: NgForm) {
    if (form.invalid || this.isSubmitting) return;

    this.isSubmitting = true;
    this.errorMessage = '';
    this.successMessage = '';

    try {
      const user = await firstValueFrom(this.auth.user$);
      if (!user) {
        this.errorMessage = 'Vous devez √™tre connect√©.';
        this.isSubmitting = false;
        return;
      }

      const roles = (user as any).roles || [];
      const isAdmin =
        Array.isArray(roles) && roles.includes('admin');

      // ‚úÖ Si admin -> approved, sinon -> pending
      const status: 'pending' | 'approved' | 'rejected' =
        isAdmin ? 'approved' : 'pending';

      const placeData: Place = {
        name: this.model.name!.trim(),
        description: this.model.description!.trim(),
        latitude: this.model.latitude!,
        longitude: this.model.longitude!,
        categories: this.model.categories || [],
        images: this.model.images || [],
        videos: this.model.videos || [],
        status,
        createdBy: (user as any).uid || (user as any).id || 'unknown',
        createdAt: new Date()
      };

      await this.placesService.addPlace(placeData);

      this.successMessage = isAdmin
        ? 'Lieu ajout√© et publi√© avec succ√®s !'
        : 'Lieu ajout√© ! En attente de validation par un administrateur.';

      form.resetForm({
        latitude: 34.71,
        longitude: 11.15,
        categories: [],
        images: [],
        videos: []
      });
      this.model = {
        latitude: 34.71,
        longitude: 11.15,
        categories: [],
        images: [],
        videos: [],
        status: 'pending'
      };
      this.updateMarker(34.71, 11.15);

      setTimeout(() => this.router.navigate(['/']), 1500);
    } catch (err) {
      console.error(err);
      this.errorMessage = "Erreur lors de l'enregistrement.";
    } finally {
      this.isSubmitting = false;
    }
  }
}


// Fichier: src/app/features/admin/pages/admin-list/admin-list.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule } from '@angular/router';
import { Observable, of, firstValueFrom } from 'rxjs';

import { PlacesService } from '../../../../core/services/places.service';
import { Place } from '../../../../core/models/place.model';
import { AuthService } from '../../../../core/services/auth.service';

@Component({
  selector: 'app-admin-list',
  standalone: true,
  imports: [CommonModule, RouterModule],
  templateUrl: './admin-list.component.html',
  styles: [`
    .card { @apply bg-white rounded-lg shadow p-6 mb-4; }
    .btn { @apply px-3 py-2 rounded text-sm font-semibold transition; }
    .btn-approve { @apply bg-green-600 text-white hover:bg-green-700; }
    .btn-reject { @apply bg-red-600 text-white hover:bg-red-700; }
    .badge { @apply inline-block text-xs px-2 py-1 rounded-full; }
  `]
})
export class AdminListComponent implements OnInit {
  private placesService = inject(PlacesService);
  private authService = inject(AuthService);

  // Pour admins : lieux en attente
  pendingPlaces$: Observable<Place[]> = of([]);

  // Pour non-admins : leurs propres lieux
  userPlaces$: Observable<Place[]> = of([]);

  isAdmin = false;
  currentUserId: string | null = null;

  isProcessingId: string | null = null;
  message = '';

  ngOnInit(): void {
    this.authService.user$.subscribe(user => {
      if (!user) {
        this.isAdmin = false;
        this.currentUserId = null;
        this.pendingPlaces$ = of([]);
        this.userPlaces$ = of([]);
        return;
      }

      const roles = (user as any)?.roles;
      const uid = (user as any)?.uid || (user as any)?.id || null;

      this.currentUserId = uid;
      this.isAdmin = Array.isArray(roles) && roles.includes('admin');

      if (this.isAdmin) {
        // üõ° Admin : voit les lieux en attente
        this.pendingPlaces$ = this.placesService.getPendingPlaces();
        this.userPlaces$ = of([]);
      } else if (uid) {
        // üë§ Utilisateur normal : voit SES lieux ajout√©s
        this.userPlaces$ = this.placesService.getPlacesByUser(uid);
        this.pendingPlaces$ = of([]);
      }
    });
  }

  // ‚úÖ Valider un lieu (admin uniquement)
  async approve(place: Place) {
    if (!place.id) return;

    this.isProcessingId = place.id;
    this.message = '';

    try {
      const admin = await firstValueFrom(this.authService.user$);
      const adminId =
        (admin as any)?.uid ||
        (admin as any)?.id ||
        null;

      if (!this.isAdmin || !adminId) {
        this.message = '‚ùå Action r√©serv√©e aux administrateurs.';
        this.isProcessingId = null;
        return;
      }

      await this.placesService.approvePlace(place.id, adminId);
      this.message = `‚úÖ Lieu "${place.name}" approuv√©.`;
    } catch (err) {
      console.error(err);
      this.message = `‚ùå Erreur lors de la validation de "${place.name}".`;
    } finally {
      this.isProcessingId = null;
    }
  }

  // ‚ùå Rejeter un lieu (admin uniquement)
  async reject(place: Place) {
    if (!place.id) return;

    const confirmReject = window.confirm(
      `√ätes-vous s√ªr de vouloir rejeter le lieu "${place.name}" ?`
    );
    if (!confirmReject) return;

    this.isProcessingId = place.id;
    this.message = '';

    try {
      if (!this.isAdmin) {
        this.message = '‚ùå Action r√©serv√©e aux administrateurs.';
        this.isProcessingId = null;
        return;
      }

      await this.placesService.rejectPlace(place.id);
      this.message = `‚úÖ Lieu "${place.name}" rejet√©.`;
    } catch (err) {
      console.error(err);
      this.message = `‚ùå Erreur lors du rejet de "${place.name}".`;
    } finally {
      this.isProcessingId = null;
    }
  }
}


// Fichier: src/app/features/map/components/place-header.component.ts
import { Component, Input } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Place } from '../../../core/models/place.model';

@Component({
  selector: 'app-place-header',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './place-header.component.html'
})
export class PlaceHeaderComponent {
  @Input() place: Place | undefined;
  @Input() averageRating: number | null = null;
  @Input() commentsCount = 0;
}


// Fichier: src/app/features/map/components/place-edit-modal.component.ts
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { Place } from '../../../core/models/place.model';

@Component({
  selector: 'app-place-edit-modal',
  standalone: true,
  imports: [CommonModule, FormsModule],
  templateUrl: './place-edit-modal.component.html'
})
export class PlaceEditModalComponent {
  @Input() place: Place | null = null;
  @Input() categories: string[] = [];
  @Input() isSaving = false;
  @Input() uploadError: string | null = null;

  @Output() cancel = new EventEmitter<void>();
  @Output() save = new EventEmitter<Place>();

  onCancel() {
    this.cancel.emit();
  }

  onSubmit() {
    if (!this.place) return;
    this.save.emit(this.place);
  }
}


// Fichier: src/app/features/map/components/place-comments.component.ts
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

export interface PlaceComment {
  userName: string;
  rating: number;
  comment: string;
  createdAt: Date;
}

@Component({
  selector: 'app-place-comments',
  standalone: true,
  imports: [CommonModule, FormsModule],
  templateUrl: './place-comments.component.html'
})
export class PlaceCommentsComponent {
  @Input() comments: (PlaceComment & { displayName?: string })[] = [];
  @Input() isLoggedIn = false;
  @Input() currentUserName: string | null = null;
  @Input() isSubmitting = false;

  @Output() submitComment = new EventEmitter<{ rating: number; text: string }>();

  newRating = 5;
  newText = '';

  onSubmit() {
    const text = this.newText.trim();
    if (!text || !this.isLoggedIn) return;

    this.submitComment.emit({
      rating: this.newRating,
      text
    });

    this.newText = '';
    this.newRating = 5;
  }
}


// Fichier: src/app/features/map/components/place-media-gallery.component.ts
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Place } from '../../../core/models/place.model';

@Component({
  selector: 'app-place-media-gallery',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './place-media-gallery.component.html'
})
export class PlaceMediaGalleryComponent {
  @Input() place: Place | undefined;
  @Input() uploadingImages = false;
  @Input() uploadingVideos = false;
  @Input() uploadError: string | null = null;

  // Afficher les champs d'upload seulement en mode √©dition
  @Input() editMode = false;

  @Output() addImages = new EventEmitter<FileList>();
  @Output() addVideos = new EventEmitter<FileList>();

  // √âtat pour la galerie plein √©cran
  isLightboxOpen = false;
  lightboxType: 'image' | 'video' | null = null;
  lightboxIndex = 0;

  get images(): string[] {
    return this.place?.images ?? [];
  }

  get videos(): string[] {
    // selon ton mod√®le, adapte le champ (videos, mediaVideos, etc.)
    // @ts-ignore
    return this.place?.videos ?? [];
  }

  onImagesSelected(event: Event) {
    const input = event.target as HTMLInputElement;
    if (input.files && input.files.length) {
      this.addImages.emit(input.files);
    }
  }

  onVideosSelected(event: Event) {
    const input = event.target as HTMLInputElement;
    if (input.files && input.files.length) {
      this.addVideos.emit(input.files);
    }
  }

  openImage(index: number) {
    if (this.images.length === 0) {
      return;
    }
    this.lightboxType = 'image';
    this.lightboxIndex = index;
    this.isLightboxOpen = true;
  }

  openVideo(index: number) {
    if (this.videos.length === 0) {
      return;
    }
    this.lightboxType = 'video';
    this.lightboxIndex = index;
    this.isLightboxOpen = true;
  }

  closeLightbox() {
    this.isLightboxOpen = false;
  }

  next() {
    if (!this.lightboxType) return;

    if (this.lightboxType === 'image' && this.images.length > 0) {
      this.lightboxIndex = (this.lightboxIndex + 1) % this.images.length;
    } else if (this.lightboxType === 'video' && this.videos.length > 0) {
      this.lightboxIndex = (this.lightboxIndex + 1) % this.videos.length;
    }
  }

  prev() {
    if (!this.lightboxType) return;

    if (this.lightboxType === 'image' && this.images.length > 0) {
      this.lightboxIndex =
        (this.lightboxIndex - 1 + this.images.length) % this.images.length;
    } else if (this.lightboxType === 'video' && this.videos.length > 0) {
      this.lightboxIndex =
        (this.lightboxIndex - 1 + this.videos.length) % this.videos.length;
    }
  }
}


// Fichier: src/app/features/map/components/place-info.component.ts
import { Component, Input } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Place } from '../../../core/models/place.model';

@Component({
  selector: 'app-place-info',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './place-info.component.html'
})
export class PlaceInfoComponent {
  @Input() place: Place | undefined;
}


// Fichier: src/app/features/map/components/place-admin-actions.component.ts
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Place } from '../../../core/models/place.model';

@Component({
  selector: 'app-place-admin-actions',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './place-admin-actions.component.html'
})
export class PlaceAdminActionsComponent {
  @Input() place: Place | undefined;
  @Input() isAdmin = false;

  @Output() edit = new EventEmitter<Place>();
  @Output() delete = new EventEmitter<Place>();

  onEdit() {
    if (this.place) this.edit.emit(this.place);
  }

  onDelete() {
    if (this.place) this.delete.emit(this.place);
  }
}


// Fichier: src/app/features/map/components/place-map-card.component.ts
import { Component, Input } from '@angular/core';
import { CommonModule } from '@angular/common';
import { LeafletModule } from '@bluehalo/ngx-leaflet';
import * as L from 'leaflet';

@Component({
  selector: 'app-place-map-card',
  standalone: true,
  imports: [CommonModule, LeafletModule],
  templateUrl: './place-map-card.component.html'
})
export class PlaceMapCardComponent {
  @Input() mapOptions!: L.MapOptions;
  @Input() mapLayers: L.Layer[] = [];
}


// Fichier: src/app/features/map/pages/map-page/map-page.component.ts
import { Component, OnInit, OnDestroy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { LeafletModule } from '@bluehalo/ngx-leaflet';
import { Router, RouterModule } from '@angular/router';
import * as L from 'leaflet';
import { PlacesService } from '../../../../core/services/places.service';
import { Place } from '../../../../core/models/place.model';
import { Subscription } from 'rxjs';

@Component({
  selector: 'app-map-page',
  standalone: true,
  imports: [CommonModule, LeafletModule, RouterModule],
  templateUrl: './map-page.component.html',
  styleUrls: ['./map-page.component.css']
})
export class MapPageComponent implements OnInit, OnDestroy {
  // Centr√© sur Kerkennah avec un zoom adapt√©
  options: L.MapOptions = {
    layers: [L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 18 })],
    zoom: 11,
    center: L.latLng(34.71, 11.15)
  };

  places: Place[] = [];
  layers: L.Layer[] = [];
  private sub: Subscription = new Subscription();

  constructor(private placesService: PlacesService, private router: Router) {}

  ngOnInit(): void {
    this.sub = this.placesService.getApprovedPlaces().subscribe(data => {
      this.places = data;
      this.updateMarkers();
    });
  }

  ngOnDestroy(): void {
    this.sub.unsubscribe();
  }

  /**
   * D√©termine l'ic√¥ne et la couleur en fonction des cat√©gories
   */
  getIcon(categories: string[]) {
    let type = 'default';
    let emoji = 'üìç';
    
    // On convertit tout en minuscule pour la recherche insensible √† la casse
    const c = categories.map(x => x.toLowerCase()).join(' ');
    
    // LOGIQUE DE PRIORIT√â
    
    // 1. Sant√© & Urgences
    if (c.includes('pharmacie') || c.includes('h√¥pital') || c.includes('sant√©') || c.includes('urgences')) {
      type = 'sante'; emoji = 'üè•';
    }
    // 2. √âducation & Administration
    else if (c.includes('√©cole') || c.includes('lyc√©e') || c.includes('coll√®ge') || c.includes('poste') || c.includes('mairie') || c.includes('ville')) {
      type = 'ecole'; emoji = 'üéì'; // ou üè¢ pour admin
      if (c.includes('poste') || c.includes('mairie')) emoji = 'üè¢';
    }
    // 3. Restauration
    else if (c.includes('restaurant') || c.includes('snack') || c.includes('pizzeria') || c.includes('fast food')) {
      type = 'restaurant'; emoji = 'üç¥';
    }
    else if (c.includes('caf√©') || c.includes('salon de th√©') || c.includes('buvette')) {
      type = 'cafe'; emoji = '‚òï';
    }
    // 4. H√©bergement
    else if (c.includes('h√¥tel') || c.includes('hotel') || c.includes('r√©sidence') || c.includes('maison d\'h√¥tes')) {
      type = 'hotel'; emoji = 'üè®';
    }
    // 5. Loisirs & Nature
    else if (c.includes('plage') || c.includes('baignade') || c.includes('mer')) {
      type = 'plage'; emoji = 'üèñÔ∏è';
    }
    else if (c.includes('port') || c.includes('p√™che') || c.includes('bateau')) {
      type = 'port'; emoji = '‚öì';
    }
    // 6. Culture & Religion
    else if (c.includes('mosqu√©e') || c.includes('zaouia')) {
      type = 'culture'; emoji = 'üïå';
    }
    else if (c.includes('histoire') || c.includes('mus√©e') || c.includes('ruine') || c.includes('site')) {
      type = 'culture'; emoji = 'üèõÔ∏è';
    }
    // 7. Commerce
    else if (c.includes('commerce') || c.includes('√©picerie') || c.includes('magasin') || c.includes('march√©')) {
      type = 'ecole'; emoji = 'üõí'; // On r√©utilise le bleu ou on cr√©e une classe commerce
    }

    return L.divIcon({
      className: 'custom-div-icon',
      html: `<div class="marker-pin ${type}"><span>${emoji}</span></div>`,
      iconSize: [42, 42],
      iconAnchor: [21, 42],
      popupAnchor: [0, -45]
    });
  }

  updateMarkers() {
    this.layers = this.places.map(p => {
      const m = L.marker([p.latitude, p.longitude], { 
        icon: this.getIcon(p.categories || []) 
      });
      
      // Gestion image (si tableau vide ou erreur, image par d√©faut)
      const img = (p.images && p.images.length > 0) 
        ? p.images[0] 
        : 'https://upload.wikimedia.org/wikipedia/commons/thumb/a/ac/No_image_available.svg/300px-No_image_available.svg.png';
      
      // Popup HTML
      m.bindPopup(`
        <div class="text-center font-sans">
          <h3 class="font-bold text-base text-gray-800 mb-2 truncate">${p.name}</h3>
          <div class="relative">
             <img src="${img}" class="popup-image" onerror="this.src='https://via.placeholder.com/300?text=Image+Indisponible'">
             <span class="absolute bottom-3 right-1 bg-white/80 px-1 rounded text-[10px] font-bold text-gray-600">
               ${p.categories[0] || 'Lieu'}
             </span>
          </div>
          <button id="btn-${p.id}" 
            class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-full text-xs font-bold w-full transition shadow-sm flex items-center justify-center gap-1">
            <span>üëÅÔ∏è</span> Voir D√©tails
          </button>
        </div>
      `);
      
      m.on('popupopen', () => {
        const btn = document.getElementById(`btn-${p.id}`);
        if (btn) btn.addEventListener('click', () => this.router.navigate(['/place', p.id]));
      });
      
      return m;
    });
  }

  onMapReady(map: L.Map) {
    // Optionnel: Ajustements au chargement de la carte
  }
}


// Fichier: src/app/features/map/pages/place-detail/place-detail.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { PlaceHeaderComponent } from '../../components/place-header.component';
import { PlaceInfoComponent } from '../../components/place-info.component';
import { PlaceAdminActionsComponent } from '../../components/place-admin-actions.component';
import { PlaceCommentsComponent } from '../../components/place-comments.component';
import { PlaceMediaGalleryComponent } from '../../components/place-media-gallery.component';
import { PlaceMapCardComponent } from '../../components/place-map-card.component';
import { PlaceEditModalComponent } from '../../components/place-edit-modal.component';
import { ActivatedRoute, RouterModule, Router } from '@angular/router';
import { LeafletModule } from '@bluehalo/ngx-leaflet';
import * as L from 'leaflet';
import { Observable, of } from 'rxjs';
import { switchMap, tap, map } from 'rxjs/operators';
import { FormsModule } from '@angular/forms';

import { PlacesService } from '../../../../core/services/places.service';
import { Place } from '../../../../core/models/place.model';
import { AuthService } from '../../../../core/services/auth.service';
import { SupabaseImageService } from '../../../../core/services/supabase-image.service';

interface PlaceComment {
  userName: string;
  rating: number;
  comment: string;
  createdAt: Date;
}

@Component({
  selector: 'app-place-detail',
  standalone: true,
  imports: [CommonModule, PlaceHeaderComponent, PlaceInfoComponent, PlaceAdminActionsComponent, PlaceCommentsComponent, PlaceMediaGalleryComponent, PlaceMapCardComponent, PlaceEditModalComponent],
  templateUrl: './place-detail.component.html',
  styleUrls: ['./place-detail.component.css']
})
export class PlaceDetailComponent implements OnInit {
  private route = inject(ActivatedRoute);
  private router = inject(Router);
  private placesService = inject(PlacesService);
  private authService = inject(AuthService);
  private supabaseImageService = inject(SupabaseImageService);

  // Place affich√©e
  place$: Observable<Place | undefined> = of(undefined);

  // Admin / connexion
  isAdmin = false;
  isLoggedIn = false;
  currentUserName: string | null = null;

  // Modal √©dition
  showEditModal = false;
  editingPlace: Place | null = null;

  // Upload √©tats
  uploadingImages = false;
  uploadingVideos = false;
  uploadError: string | null = null;

  // Galerie plein √©cran
  showMediaViewer = false;
  mediaViewerItems: { type: 'image' | 'video'; src: string }[] = [];
  mediaViewerIndex = 0;

  // Avis / commentaires
  comments: PlaceComment[] = [];
  newCommentRating = 5;
  newCommentText = '';
  isSubmittingComment = false;

  // Liste de cat√©gories disponibles
  availableCategories: string[] = [
    'Restaurant',
    'Fruits de mer',
    'Caf√©',
    'Fast-food',
    'Pizzeria',
    'Boulangerie',
    'Glacier',
    'Bar',
    'H√¥tel',
    'H√©bergement',
    'Activit√©',
    'Culture',
    'Sport',
    'Shopping',
    'Autre'
  ];

  // Config Leaflet
  mapOptions: L.MapOptions = {
    layers: [
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18
      })
    ],
    zoom: 14,
    center: L.latLng(34.71, 11.15)
  };

  mapLayers: L.Layer[] = [];

  constructor() {
    // Patch ic√¥nes Leaflet (pour √©viter les probl√®mes de bundling)
    const iconRetinaUrl =
      'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-2x.png';
    const iconUrl = 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png';
    const shadowUrl =
      'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png';

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (L.Marker as any).prototype.options.icon = L.icon({
      iconRetinaUrl,
      iconUrl,
      shadowUrl,
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41]
    });
  }

  ngOnInit(): void {
    // Gestion connexion / admin avec AuthService (fa√ßon "safe" via any)
    const anyAuth = this.authService as any;

    if (anyAuth.user$ && typeof anyAuth.user$.subscribe === 'function') {
      anyAuth.user$.subscribe((user: any) => {
        this.isLoggedIn = !!user;
        if (user) {
          this.currentUserName =
            user.fullName || user.name || user.email || 'Utilisateur';

          if (Array.isArray(user.roles)) {
            this.isAdmin = user.roles.includes('admin');
          }
        } else {
          this.currentUserName = null;
          this.isAdmin = false;
        }
      });
    } else if (anyAuth.isLoggedIn$ && typeof anyAuth.isLoggedIn$.subscribe === 'function') {
      anyAuth.isLoggedIn$.subscribe((logged: any) => {
        this.isLoggedIn = !!logged;
      });
    } else if (typeof anyAuth.isLoggedIn === 'boolean') {
      this.isLoggedIn = anyAuth.isLoggedIn;
    }

    // R√©cup√©rer la place & normaliser les dates
    this.place$ = this.route.paramMap.pipe(
      switchMap((params) => {
        const id = params.get('id');
        if (!id) {
          return of(undefined);
        }
        return this.placesService.getPlaceById(id);
      }),
      map((place: Place | undefined) =>
        place ? this.normalizePlaceDates(place) : undefined
      ),
      tap((place) => {
        if (place) {
          this.updateMap(place);
        }
      })
    );
  }

  /**
   * Convertit les champs de type Timestamp / string / number en Date
   * pour que le DatePipe Angular les accepte.
   */
  private normalizePlaceDates(place: Place): Place {
    const convert = (v: any): Date | undefined => {
      if (!v) return undefined;
      if (v instanceof Date) return v;
      // Firestore / Supabase Timestamp avec m√©thode toDate()
      if (typeof v.toDate === 'function') return v.toDate();
      // Objet { seconds, nanoseconds }
      if (typeof v.seconds === 'number') {
        return new Date(v.seconds * 1000);
      }
      // nombre (ms)
      if (typeof v === 'number') return new Date(v);
      // string parsable
      const parsed = new Date(v);
      if (!isNaN(parsed.getTime())) return parsed;
      return undefined;
    };

    return {
      ...place,
      createdAt: convert((place as any).createdAt) as any,
      updatedAt: convert((place as any).updatedAt) as any,
      validatedAt: convert((place as any).validatedAt) as any
    };
  }

  private updateMap(place: Place) {
    if (place.latitude && place.longitude) {
      this.mapOptions = {
        ...this.mapOptions,
        center: L.latLng(place.latitude, place.longitude)
      };

      this.mapLayers = [
        L.marker([place.latitude, place.longitude]).bindPopup(place.name)
      ];
    }
  }

  // -------- AVIS / COMMENTAIRES --------

  get averageRating(): number | null {
    if (!this.comments.length) {
      return null;
    }
    const sum = this.comments.reduce((acc, c) => acc + c.rating, 0);
    return Math.round((sum / this.comments.length) * 10) / 10;
  }

  submitComment(): void {
    if (!this.isLoggedIn) {
      return;
    }
    const text = this.newCommentText.trim();
    if (!text) {
      return;
    }

    this.isSubmittingComment = true;

    const newComment: PlaceComment = {
      userName: this.currentUserName || 'Utilisateur',
      rating: this.newCommentRating,
      comment: text,
      createdAt: new Date()
    };

    // Pour l‚Äôinstant, stockage local uniquement (pas de backend)
    this.comments = [newComment, ...this.comments];

    this.newCommentText = '';
    this.newCommentRating = 5;
    this.isSubmittingComment = false;
  }

  // -------- MODAL √âDITION --------

  openEditModal(place: Place) {
    this.uploadError = null;
    this.uploadingImages = false;
    this.uploadingVideos = false;

    // On clone la place pour ne pas modifier l'original tant que ce n'est pas sauvegard√©
    this.editingPlace = {
      ...place,
      images: [...(place.images || [])],
      videos: [...(place.videos || [])],
      categories: [...(place.categories || [])]
    };
    this.showEditModal = true;
  }

  closeEditModal() {
    this.showEditModal = false;
    this.editingPlace = null;
    this.uploadError = null;
    this.uploadingImages = false;
    this.uploadingVideos = false;
  }

  // -------- CATEGORIES --------

  toggleCategory(category: string) {
    if (!this.editingPlace) return;

    const categories = this.editingPlace.categories || [];
    const index = categories.indexOf(category);
    if (index > -1) {
      categories.splice(index, 1);
    } else {
      categories.push(category);
    }
    this.editingPlace = {
      ...this.editingPlace,
      categories: [...categories]
    };
  }

  // -------- IMAGES --------

  async onImagesSelected(event: Event) {
    if (!this.editingPlace) return;

    const input = event.target as HTMLInputElement;
    if (!input.files || input.files.length === 0) return;

    const files = Array.from(input.files);

    this.uploadingImages = true;
    this.uploadError = null;

    try {
      const baseId = this.editingPlace.id || 'temp';
      const uploadPromises = files.map((file, index) =>
        this.supabaseImageService.uploadImage(
          file,
          `places/${baseId}/images/${Date.now()}-${index}-${file.name}`
        )
      );

      const results = await Promise.all(uploadPromises);
      const urls = results.filter((u): u is string => !!u);

      const existing = this.editingPlace.images || [];
      this.editingPlace = {
        ...this.editingPlace,
        images: [...existing, ...urls]
      };
    } catch (err) {
      console.error('Erreur upload images', err);
      this.uploadError = "Erreur lors de l'upload des images.";
    } finally {
      this.uploadingImages = false;
    }
  }

  removeImage(index: number) {
    if (!this.editingPlace) return;
    const images = [...(this.editingPlace.images || [])];
    images.splice(index, 1);
    this.editingPlace = {
      ...this.editingPlace,
      images
    };
  }

  // -------- VIDEOS --------

  async onVideosSelected(event: Event) {
    if (!this.editingPlace) return;

    const input = event.target as HTMLInputElement;
    if (!input.files || input.files.length === 0) return;

    const files = Array.from(input.files);

    this.uploadingVideos = true;
    this.uploadError = null;

    try {
      const baseId = this.editingPlace.id || 'temp';
      const uploadPromises = files.map((file, index) =>
        // On r√©utilise uploadImage pour les vid√©os (Supabase se fiche du type)
        this.supabaseImageService.uploadImage(
          file,
          `places/${baseId}/videos/${Date.now()}-${index}-${file.name}`
        )
      );

      const results = await Promise.all(uploadPromises);
      const urls = results.filter((u): u is string => !!u);

      const existing = this.editingPlace.videos || [];
      this.editingPlace = {
        ...this.editingPlace,
        videos: [...existing, ...urls]
      };
    } catch (err) {
      console.error('Erreur upload vid√©os', err);
      this.uploadError = "Erreur lors de l'upload des vid√©os.";
    } finally {
      this.uploadingVideos = false;
    }
  }

  removeVideo(index: number) {
    if (!this.editingPlace) return;
    const videos = [...(this.editingPlace.videos || [])];
    videos.splice(index, 1);
    this.editingPlace = {
      ...this.editingPlace,
      videos
    };
  }

  // -------- SAUVEGARDE --------

  async savePlace() {
    if (!this.editingPlace || !this.editingPlace.id) return;

    const id = this.editingPlace.id;

    const payload: Partial<Place> = {
      ...this.editingPlace,
      updatedAt: new Date()
    };

    try {
      await this.placesService.updatePlace(id, payload);
      this.closeEditModal();

      // Recharger la place pour raffra√Æchir l'affichage
      this.place$ = this.placesService.getPlaceById(id).pipe(
        map((place) => (place ? this.normalizePlaceDates(place) : undefined)),
        tap((place) => {
          if (place) {
            this.updateMap(place);
          }
        })
      );
    } catch (err) {
      console.error('Erreur lors de la mise √† jour du lieu', err);
      this.uploadError = 'Erreur lors de la sauvegarde du lieu.';
    }
  }

  // -------- SUPPRESSION --------

  async onDeletePlace(place: Place) {
    if (!this.isAdmin || !place.id) return;

    const ok = window.confirm(
      '√ätes-vous s√ªr de vouloir supprimer d√©finitivement ce lieu ?'
    );
    if (!ok) return;

    try {
      await this.placesService.deletePlace(place.id);
      this.router.navigate(['/']);
    } catch (err) {
      console.error('Erreur lors de la suppression du lieu', err);
      alert('Erreur lors de la suppression du lieu.');
    }
  }

  // ---------- GALERIE PLEIN √âCRAN (images + vid√©os) ----------

  openMediaViewerFromImage(place: Place, imageIndex: number): void {
    const images = place.images ?? [];
    const videos = place.videos ?? [];

    this.mediaViewerItems = [
      ...images.map((src) => ({ type: 'image' as const, src })),
      ...videos.map((src) => ({ type: 'video' as const, src }))
    ];

    this.mediaViewerIndex = Math.min(
      Math.max(imageIndex, 0),
      this.mediaViewerItems.length - 1
    );
    this.showMediaViewer = this.mediaViewerItems.length > 0;
  }

  openMediaViewerFromVideo(place: Place, videoIndex: number): void {
    const images = place.images ?? [];
    const videos = place.videos ?? [];

    this.mediaViewerItems = [
      ...images.map((src) => ({ type: 'image' as const, src })),
      ...videos.map((src) => ({ type: 'video' as const, src }))
    ];

    const startIndex = images.length + videoIndex;
    this.mediaViewerIndex = Math.min(
      Math.max(startIndex, 0),
      this.mediaViewerItems.length - 1
    );
    this.showMediaViewer = this.mediaViewerItems.length > 0;
  }

  closeMediaViewer(): void {
    this.showMediaViewer = false;
  }

  nextMedia(): void {
    if (!this.mediaViewerItems.length) return;
    this.mediaViewerIndex =
      (this.mediaViewerIndex + 1) % this.mediaViewerItems.length;
  }

  prevMedia(): void {
    if (!this.mediaViewerItems.length) return;
    this.mediaViewerIndex =
      (this.mediaViewerIndex - 1 + this.mediaViewerItems.length) %
      this.mediaViewerItems.length;
  }

  get currentMedia():
    | { type: 'image' | 'video'; src: string }
    | null {
    if (!this.mediaViewerItems.length) return null;
    return this.mediaViewerItems[this.mediaViewerIndex];
  }

  // ===== Auto-added stubs for place-detail refactor =====
  // TODO: remplace ces stubs par ta vraie logique (upload, commentaires, √©dition, etc.)

  // Indique si un enregistrement de lieu est en cours (utilis√© par app-place-edit-modal)
  isSavingPlace = false;

  // Handler appel√© par app-place-media-gallery lorsqu'on ajoute des images
  onUploadImages(files: FileList) {
    // TODO: impl√©menter la logique d'upload d'images
    console.warn('[PlaceDetailComponent] onUploadImages stub - implement me', files);
  }

  // Handler appel√© par app-place-media-gallery lorsqu'on ajoute des vid√©os
  onUploadVideos(files: FileList) {
    // TODO: impl√©menter la logique d'upload de vid√©os
    console.warn('[PlaceDetailComponent] onUploadVideos stub - implement me', files);
  }

  // Handler appel√© par app-place-comments lorsqu'on soumet un commentaire
  
  // ===== Auto-wired handler: ajoute le commentaire dans la liste locale =====
  onSubmitComment(event: { rating: number; text: string }) {
    (this as any).isSubmittingComment = true;

    const newComment: any = {
rating: event.rating,
      comment: event.text,
      displayName: (this as any).currentUserName ?? 'Vous',
      createdAt: new Date().toISOString()
    };

    const current = (this as any).comments || [];
    (this as any).comments = [newComment, ...current];

    (this as any).isSubmittingComment = false;
  }


  // Handler appel√© par app-place-edit-modal lorsqu'on sauvegarde le lieu √©dit√©
  onSaveEditedPlace(updatedPlace: any) {
    // TODO: impl√©menter la logique de sauvegarde du lieu (appel API, etc.)
    console.warn('[PlaceDetailComponent] onSaveEditedPlace stub - implement me', updatedPlace);
  }
  // ===== End auto-added stubs for place-detail refactor =====

}


// Fichier: src/app/app.component.ts
import { Component } from '@angular/core';
import { RouterOutlet } from '@angular/router';
import { HeaderComponent } from './core/components/header/header.component';
import { FooterComponent } from './core/components/footer/footer.component';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [RouterOutlet, HeaderComponent, FooterComponent],
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {}


// Fichier: src/app/app-routing-module.ts
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';

// Composants (Chemins bas√©s sur l'architecture du script 02)
import { MapPageComponent } from './features/map/pages/map-page/map-page.component';
import { PlaceDetailComponent } from './features/map/pages/place-detail/place-detail.component';
import { AddPlaceComponent } from './features/admin/pages/add-place/add-place.component';
import { LoginComponent } from './features/auth/pages/login/login.component';
import { AdminListComponent } from './features/admin/pages/admin-list/admin-list.component';

// Guards
import { AuthGuard } from './core/guards/auth.guard';
import { AdminGuard } from './core/guards/admin.guard';

const routes: Routes = [
  // Route par d√©faut : Carte
  { path: '', component: MapPageComponent },

  // D√©tail d'un lieu
  { path: 'place/:id', component: PlaceDetailComponent },

  // Ajout d'un lieu (Prot√©g√© par AuthGuard)
  { path: 'add-place', component: AddPlaceComponent, canActivate: [AuthGuard] },

  // Login
  { path: 'login', component: LoginComponent },

  // Section Admin (Prot√©g√©e par AdminGuard)
  { 
    path: 'admin',
    canActivate: [AdminGuard],
    children: [
        { path: 'places', component: AdminListComponent },
        // On pourrait ajouter une route pour les lieux 'pending' sp√©cifiquement ici
        { path: 'places/pending', component: AdminListComponent }, 
        { path: '', redirectTo: 'places', pathMatch: 'full' }
    ]
  },

  // Redirection wildcard
  { path: '**', redirectTo: '' }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }


